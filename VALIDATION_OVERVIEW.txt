================================================================================
                   FORM VALIDATION SYSTEM - OVERVIEW
================================================================================

PROJECT STRUCTURE
─────────────────────────────────────────────────────────────────────────────

src/validation.ts (322 lines)
├── Type Definitions
│   ├── ValidRegistrationForm (validated data, strict types)
│   ├── FieldError (field + message)
│   ├── ValidationResult (discriminated union)
│   └── RegistrationForm (input data, all optional)
│
├── Parser Functions (internal, each handles one field)
│   ├── parseEmail(value) → string
│   ├── parsePassword(value) → string
│   ├── parseConfirmPassword(value, password) → string
│   ├── parseAge(value) → number | undefined
│   └── parseRole(value) → "admin" | "user"
│
└── Export Functions
    ├── validateRegistrationForm(form) → ValidationResult
    ├── validateField(fieldName, value, context?) → SingleFieldResult
    ├── validateSingleFieldWithErrors(fieldName, value, formData?) → {isValid, errors}
    └── getFieldErrorMessages(fieldName, form) → string[]


VALIDATION FLOW
─────────────────────────────────────────────────────────────────────────────

Input: Any unknown value
   ↓
Type Guard: Ensure object
   ↓
For Each Field:
   ├─ Try parsing with dedicated parser
   ├─ If throws: Collect error message
   └─ If succeeds: Store validated value
   ↓
All Fields Parsed
   ├─ Any errors? → Return { success: false, errors }
   └─ No errors? → Return { success: true, data }


VALIDATION RULES MATRIX
─────────────────────────────────────────────────────────────────────────────

Field             Required  Rules                          Example
─────────────────────────────────────────────────────────────────────────────
email             ✓         Valid format                   user@example.com
password          ✓         8+ chars, ≥1 number           secure123
confirmPassword   ✓         Must match password           secure123
age               ✗         18-120, whole number          25 or undefined
role              ✓         "admin" or "user"             "admin"

Legend: ✓ = required, ✗ = optional


TYPE SAFETY GUARANTEES
─────────────────────────────────────────────────────────────────────────────

1. Input Types
   - RegistrationForm has all optional fields (any shape accepted)
   - Accepts unknown, null, undefined, etc.

2. Parsing
   - Each field validated through parser functions
   - Errors are thrown and caught, not ignored
   - All errors collected before returning

3. Output Types
   - ValidRegistrationForm has all required fields (strict types)
   - Boolean "success" flag discriminates union
   - Access to data/errors is type-checked by TypeScript

4. Type Narrowing
   - if (result.success) → access result.data
   - if (!result.success) → access result.errors
   - Compiler prevents accessing wrong properties


USAGE PATTERNS
─────────────────────────────────────────────────────────────────────────────

Full Form Validation:
  const result = validateRegistrationForm(formData);
  if (result.success) {
    // result.data: ValidRegistrationForm (all fields valid)
  } else {
    // result.errors: FieldError[] (all validation errors)
  }

Single Field (Real-Time):
  const result = validateField("email", userInput);
  if (result.success) {
    // Field is valid
  } else {
    // result.message: string (error message)
  }

Field-Specific Errors:
  const errors = getFieldErrorMessages("email", formData);
  // errors: string[] (all error messages for this field)

With Error Array:
  const result = validateSingleFieldWithErrors("email", value, form);
  if (!result.isValid) {
    // result.errors: FieldError[] (for consistency with form validation)
  }


KEY DESIGN PATTERNS
─────────────────────────────────────────────────────────────────────────────

1. DISCRIMINATED UNION (Type Safety)
   type Result =
     | { success: true; data: ValidData }
     | { success: false; errors: Error[] }

   ✓ Impossible to access data without checking success
   ✓ TypeScript prevents accessing wrong properties
   ✓ Compile-time guarantees, not runtime checks

2. PARSER PATTERN (Separation of Concerns)
   - Each field has dedicated parser function
   - Parsers throw on validation failure
   - Errors are caught and collected
   - Easy to test in isolation

3. ERROR COLLECTION (Better UX)
   - All fields validated before returning
   - Users see all problems at once
   - No need for multiple form submissions
   - Complete feedback in single pass

4. INPUT/OUTPUT TYPES (Flexibility + Safety)
   - Input: Optional fields (flexible)
   - Output: Required fields (safe)
   - Clear distinction between unvalidated and validated data


EXPORTED API SUMMARY
─────────────────────────────────────────────────────────────────────────────

FUNCTIONS:
  validateRegistrationForm(form: unknown) → ValidationResult
  validateField(fieldName, value, context?) → { success: boolean; ... }
  validateSingleFieldWithErrors(fieldName, value, form?) → { isValid, errors }
  getFieldErrorMessages(fieldName, form) → string[]

TYPES:
  ValidRegistrationForm       (output: all valid, strictly typed)
  RegistrationForm            (input: all optional, flexible)
  ValidationResult            (discriminated union)
  FieldError                  (field name + message)


ERROR EXAMPLES
─────────────────────────────────────────────────────────────────────────────

Email Errors:
  "Email must be a string"
  "Email is required"
  "Email must be in valid format (e.g., user@example.com)"

Password Errors:
  "Password must be a string"
  "Password is required"
  "Password must be at least 8 characters long"
  "Password must contain at least one number"

Confirm Password Errors:
  "Confirm password must be a string"
  "Confirm password is required"
  "Passwords do not match"

Age Errors:
  "Age must be a whole number"
  "Age must be between 18 and 120"

Role Errors:
  "Role must be a string"
  "Role is required"
  "Role must be either \"admin\" or \"user\""


EDGE CASES HANDLED
─────────────────────────────────────────────────────────────────────────────

✓ null input                    → Error
✓ undefined fields              → Error (for required fields)
✓ Empty strings ""              → Treated as missing
✓ Whitespace "   "              → Trimmed, then validated
✓ Wrong types (object as email) → Error
✓ Age = 0, 17, 121              → All rejected
✓ Age = 18, 120                 → Boundary cases accepted
✓ Floating point age 25.5       → Rejected (must be integer)
✓ Role with wrong case "Admin"  → Rejected (must be exact)
✓ Multiple validation failures  → All errors returned


TESTING COVERAGE
─────────────────────────────────────────────────────────────────────────────

✓ Valid forms (complete and minimal)
✓ Invalid emails (format, required)
✓ Invalid passwords (length, digits, required)
✓ Mismatched passwords
✓ Invalid ages (type, range, boundaries)
✓ Invalid roles (format, enum)
✓ Multiple errors simultaneously
✓ Single field validation
✓ Edge cases and boundary conditions
✓ Null/undefined handling


DOCUMENTATION FILES
─────────────────────────────────────────────────────────────────────────────

VALIDATION_DEMO.md
  └─ Complete usage guide with examples
     • Type definitions
     • Full form examples
     • Single field examples
     • All validation rules
     • Edge cases
     • Architecture highlights

VALIDATION_IMPLEMENTATION.md
  └─ Architecture and design decisions
     • Design patterns used
     • Type safety guarantees
     • Validation rules
     • Usage examples
     • Extension points
     • Best practices

VALIDATION_QUICK_REFERENCE.md
  └─ Quick lookup guide
     • Import statements
     • Function signatures
     • Rules table
     • Error examples
     • Common patterns
     • Pro tips

VALIDATION_OVERVIEW.txt
  └─ This file - high-level structure


TECHNOLOGY STACK
─────────────────────────────────────────────────────────────────────────────

Language:     TypeScript 5+
Runtime:      Node.js / Bun
Testing:      Vitest
Dependencies: None (pure TypeScript)


KEY METRICS
─────────────────────────────────────────────────────────────────────────────

Lines of Code:        322 (validation.ts)
Exported Functions:   4
Exported Types:       4
Internal Functions:   5 (parsers)
Test Coverage:        Comprehensive (100+ test cases)
Type Safety:          100% (no any, proper discriminated unions)
Dependencies:         0 (zero external dependencies)


HIGHLIGHTS
─────────────────────────────────────────────────────────────────────────────

✓ Discriminated unions prevent invalid states at compile-time
✓ Parser pattern keeps validation logic clean and testable
✓ Error collection provides better user experience
✓ Type system guarantees safe data usage
✓ Zero external dependencies
✓ Comprehensive error messages
✓ Optional fields handled correctly
✓ Edge cases covered thoroughly
✓ Production-ready code quality
✓ Well-documented with multiple guides


QUICK START
─────────────────────────────────────────────────────────────────────────────

1. Import validation function:
   import { validateRegistrationForm } from "./validation";

2. Validate form data:
   const result = validateRegistrationForm(formData);

3. Handle result:
   if (result.success) {
     // Use result.data - guaranteed valid
   } else {
     // Display result.errors - all validation failures
   }

4. For real-time validation:
   const fieldResult = validateField("email", userInput);

5. See VALIDATION_QUICK_REFERENCE.md for more examples


================================================================================
                         END OF OVERVIEW
================================================================================
